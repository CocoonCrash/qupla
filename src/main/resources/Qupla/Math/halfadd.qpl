// LUT logic: return the sum of a trit plus a carry as a single trit plus a new carry
//            return (trit1 + carry), newcarry(trit1 + carry)
lut halfAdd {
  -,- = 1,- // -1 + -1 =  1, carry -1
  -,0 = -,0 // -1 +  0 = -1, carry  0
  -,1 = 0,0 // -1 +  1 =  0, carry  0
  0,- = -,0 //  0 + -1 = -1, carry  0
  0,0 = 0,0 //  0 +  0 =  0, carry  0
  0,1 = 1,0 //  0 +  1 =  1, carry  0
  1,- = 0,0 //  1 + -1 =  0, carry  0
  1,0 = 1,0 //  1 +  0 =  1, carry  0
  1,1 = -,1 //  1 +  1 = -1, carry  1
}

type TritCarry {
  value [Trit]
  carry [Carry]
}

// returns val + carry

func TritCarry halfAdd<Trit> (Trit val, Carry carry) {
  return halfAdd[val, carry]
}

template halfAdd<T> {
  type A [T / 3]
  type B [T / 3]
  type C [T / 3]
  type TCarry {
    value [T]
    carry [Carry]
  }

  func TCarry halfAdd<T> (T val, Carry carry) {
    add0 = halfAdd<A>(val[0 : A], carry)
    add1 = halfAdd<B>(val[A : B], add0.carry)
    add2 = halfAdd<C>(val[A + B : C], add1.carry)
    return add0.value & add1.value & add2
  }
}

use halfAdd<Tryte>, <Tiny>, <Int>, <Huge>, <Hash>

template halfAdd2<T> {
  type A [T / 2]
  type B [T / 2]
  type TCarry {
    value [T]
    carry [Carry]
  }

  func TCarry halfAdd<T> (T val, Carry carry) {
    add0 = halfAdd<A>(val[0 : A], carry)
    add1 = halfAdd<B>(val[A : B], add0.carry)
    return add0.value & add1
  }
}

use halfAdd2<Tryte2>, <Tiny2>, <Tiny4>, <Int2>, <Huge2>
