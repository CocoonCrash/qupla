// LUT logic: return -trit1
lut neg {
  - = 1
  0 = 0
  1 = -
}

// note that making an entire trit-vector's value negative
// can be done by simply negating every trit in the vector

// returns -val

func Trit neg<Trit> (Trit val) {
  return neg[val]
}

template neg<T> = A + B + C {
  type A [T / 3]
  type B [T / 3]
  type C [T / 3]

  func T neg<T> (T val) {
    return neg<A>(val[0 : A]) &
           neg<B>(val[A : B]) &
           neg<C>(val[A + B : C])
  }
}

use neg<Tryte>, <Tiny>, <Int>, <Huge>, <Hash>

template neg2<T> = A + B {
  type A [T / 2]
  type B [T / 2]

  func T neg<T> (T val) {
    return neg<A>(val[0 : A]) &
           neg<B>(val[A : B])
  }
}

use neg2<Tryte2>, <Tiny2>, <Tiny4>, <Int2>, <Int4>, <Huge2>


test 99 = neg<Tiny>(-99)
test 1 = neg<Tiny>(-1)
test 0 = neg<Tiny>(0)
test -1 = neg<Tiny>(1)
test -99 = neg<Tiny>(99)

test 99 = neg<Tiny2>(-99)
test 1 = neg<Tiny2>(-1)
test 0 = neg<Tiny2>(0)
test -1 = neg<Tiny2>(1)
test -99 = neg<Tiny2>(99)
