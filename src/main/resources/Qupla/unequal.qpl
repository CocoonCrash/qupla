// LUT logic: return (Bool) (trit1 != trit2)
lut unequal {
  -,- = -
  -,0 = 1
  -,1 = 1
  0,- = 1
  0,0 = -
  0,1 = 1
  1,- = 1
  1,0 = 1
  1,1 = -
}

// returns (Bool) (lhs != rhs)

func Bool unequal<Trit>(Trit lhs, Trit rhs) {
  return unequal[lhs, rhs]
}

template unequal<T> {
  type A [T / 3]
  type B [T / 3]
  type C [T / 3]

  func Bool unequal<T>(T lhs, T rhs) {
    return or3[unequal<A>(lhs[0 : A], rhs[0 : A]),
               unequal<B>(lhs[A : B], rhs[A : B]),
               unequal<C>(lhs[A + B : C], rhs[A + B : C])]
  }
}

use unequal<Tryte>, <Tiny>, <Int>, <Huge>, <Hash>

template unequal2<T> {
  type A [T / 2]
  type B [T / 2]

  func Bool unequal<T>(T lhs, T rhs) {
    return or[unequal<A>(lhs[0 : A], rhs[0 : A]),
              unequal<B>(lhs[A : B], rhs[A : B])]
  }
}

use unequal2<Tryte2>, <Tiny2>, <Tiny4>, <Int2>, <Huge2>


test - = unequal<Int>(-1, -1)
test 1 = unequal<Int>(-1, 0)
test 1 = unequal<Int>(-1, 1)
test 1 = unequal<Int>(0, -1)
test - = unequal<Int>(0, 0)
test 1 = unequal<Int>(0, 1)
test 1 = unequal<Int>(1, -1)
test 1 = unequal<Int>(1, 0)
test - = unequal<Int>(1, 1)
test 1 = unequal<Int>(10, 20)
test 1 = unequal<Int>(-30, 40)
test 1 = unequal<Int>(50, -60)
test 1 = unequal<Int>(-70, -80)
test - = unequal<Int>(90, 90)
