// return val << 1

template lshift<T> {
  func T lshift<T> (T val) {
    return val[1 : T - 1] & 0
  }
}

use lshift<Tryte>, <Tiny>, <Int>, <Huge>, <Hash>
use lshift<Tryte2>, <Tiny2>, <Tiny4>, <Int2>, <Huge2>, <Hash2>


// ************* WORK IN PROGRESS, attempt at creating lshiftN(val, n)
template lshiftN<T> {
  func T lshiftN<T> (T val, Tiny n) {
    nmin9 = sub<Tiny>(n, 9)
    sign = sign<Tiny>(nmin9)
    neg = isNegative[sign]
    pos = notNegative[sign]
    return lshiftNpart2<T>(pos ? val : null, pos ? n : null) |
           lshiftN9<T>(neg ? val : null, neg ? nmin9 : null, neg ? sign : null)
  }

  func T lshiftNpart2<T> (T val, Tiny n) {
    return lshift<T>(val)
  }

  func T lshiftN9<T> (T val, Tiny n, Trit sign) {
    lshift9 = val[Tiny : T - Tiny] & as<Tiny>(0)
    pos = isPositive[sign]
    return (isZero[sign] ? lshift9 : null) |
           lshiftN<T>(pos ? lshift9 : null, pos ? n : null)
  }
}

use lshiftN<Int>, <Huge>, <Hash>
